---
title: "Data Rescue: CPEAT 2025"
format:
  html:
    toc: true
    eval: false #default to not evaluating the chunks, override this the template is completed
date: last-modified
date-format: YYYY-MMMM
bibliography:
  - CPEAT2025_Methods.bib #contains the citations in the methods section
  - CPEAT2025.bib #contains citation for the data source, generally a single citation of the primary paper
authors: #author scheme from https://quarto.org/docs/journals/authors.html
  - id: ktoddbrown #use the github name as an id
    name:
      given: Katherine
      family: Todd-Brown
    orcid: 0000-0002-3109-8130
    affiliation:
      - ref: uf-ees
    role: #TODO define these roles and add reference
      - transcription: lead #secondary, review
      - standardization: lead #review
      - curation: lead #review
  - id: vaasukimarupaka
    name:
      given: Vaasuki
      family: Marupaka
    affiliation:
      - ref: uf-ees
    role:
      - standardization: lead
affiliations:
  - id: uf-ees
    name: University of Florida
    department: Environmental Engineering Sciences
    city: Gainesville
    state: Florida
    country: USA
    address: "365 Weil Hall \nP.O. Box 116580"
    postal-code: 32611
    url: https://essie.ufl.edu/ees/
    
timelog:
  - activity: 
      description: Merge with prior work
      who: ktoddbrown #github username
      #when you started and ended, can be just a year or down to the minute
      start: 2025-11-27T11:40
      end: T13:45
      #end: YYYY-MM-DD THH:MM
      #alternatively duration can be combined with a being/end
      duration: P2H
version: 'vs202512' #template version, remove before use
---


```{r}
#| label: setup
#| include: true
#| warning: false
#| message: false
#| echo: false


library(tidyverse) # data processing
library(kableExtra) # pretty tables
library(bibtex) # reading in BibTex files to R

# data files for level 0
methods.file <- "AuthorYYYY_Methods.md"
tableN.file <- 'AuthorYYYY_TableN.csv'
figureM.file <- 'AuthorYYYY_FigureM.csv'

dataDownload.dir <- 'temp/CPEAT'

# Bibliograph files
primaryCitation.file <- 'AuthorYYYY.bib'
methodsCitation.file <- 'CPEAT2025_Methods.bib'

# read function
readsource.file <- '../../../R/readAuthorYYYY.R'
#source('readsource.file')

#semantic files for level 1
#of_variable.file <- '../../semantics/SoilDRaHVocabulary_of_variable.csv'
#is_type.file <- '../../semantics/SoilDRaHVocabulary_is_type.csv'

```


# Data Summary

<!---- Fill in the full citation here, generally found on the journal page and link in the issue that you started on GitHub. Though this is at the top of the document, this should be one of the last things you do because a lot of this will be a direct copy-paste into the issue template. --->

> PANGAEA. n.d. “Past Global Changes - Carbon in Peat on EArth Through Time.” https://www.pangaea.de/?q=project:label:PAGES_C-PEAT. (@CPEAT2025)

Also see @CPEAT_web


<!--- After you read through the paper write a brief summary of what the study
measured and what the data was used for in. This should be <250 words.--->

CPEAT primarily measures soil organic carbon stocks of peat cores with geolocation and depth.
They use this data to look at global peat stock patterns (@Loisel2021).

## Where is the data

This data was downloaded from [https://www.pangaea.de/?q=project:label:PAGES_C-PEAT](https://www.pangaea.de/?q=project:label:PAGES_C-PEAT) using the project label `PAGES_C-PEAT` and the search function of the package `pangaear` to identify 870 unique DOIs.
Some of these DOIs have been superceded and are flagged as 'replaced by'.
All DOIs are listed in the methods BibTex file and can be compared to the `pangaear::pg_search` code in the `checkDOIs` chunk.

There is some one-off data collections for ingest that means we can not ensure that future data contributions will be consistent with what we present here.
This should be a good starting point however for adding new contributions.

```{r}
#| label: makeDownloadURLs


allMethodCitations <- bibtex::read.bib(file = methodsCitation.file)

allURLs.df <- plyr::ldply(allMethodCitations, 
                       .fun = function(xx){
                         return(c(primary = xx$url))
                       },
                       .id = 'bibKey') |>
  filter(bibKey != 'Loisel2021aa') |>
  mutate(downloadData = sprintf('%s?format=textfile', 
                                str_replace(primary, 'doi.org', 'doi.pangaea.de')))
```

```{r}
#| label: checkDOIs
#| eval: false
#| echo: false

### Query the pangaea repository
### 
temp.df <- pangaear::pg_search(query = 'project:label:PAGES_C-PEAT', count = 500) |>
  bind_rows(
    pangaear::pg_search(query = 'project:label:PAGES_C-PEAT', offset = 500, count = 500))

#is there anything new?
setdiff(paste0("https://doi.pangaea.de/",temp.df$doi, "?format=textfile"),
        allURLs.df$downloadData)
#is there anything "lost" from the search
# setdiff(allURLs.df$downloadData,
#         paste0("https://doi.pangaea.de/",temp.df$doi, "?format=textfile"))
```

## Fit for purpose: ProjectName

<!--- Write a brief discription of the project you are processing this data source for. This could be a copy-paste from other documentation. ---->

This data is identified as a data source for PROJECT.
The purpose of this PROJECT is...

<!--- Include a list of the key variables identified for the project. This is used to identify the elements for the paper for the data rescue. An example is below for a basic geo-located soil carbon stock project. --->

  - Location: The geo-location is given in the site description section of the methods. Both latitude and longitude are given but not the datum/projection that was used.
  - Soil carbon stock: Soil carbon stock was calculated from organic carbon fraction and bulk density and is reported in table 3 across two treatments and one control. Coarse fraction was not reported and does not appear to be included.
  
## Files

<!--- Include a brief explaination to all the files in the folder--->

These files are in the AuthorYYYY data rescue.

- [Readme](README_AUTHORYYYY.qmd)
  + This is the primary file that documents the transcriptions and decision made during data rescue.
- [AuthorYYYY.bib](AuthorYYYY.bib)
  + citation for article transcribed
- [AuthorYYYY_Methods.bib](AuthorYYYY_Methods.bib)
  + citations for the methods section of the article
- [AuthorYYYY_Methods.md](AuthorYYYY_Methods.md)
  + methods transcribed from primary article
- [AuthorYYYY_TableN.csv](AuthorYYYY_TableN.csv)
  + table N from primary article with ...
- [temp/](temp/)
    + scratch folder that will not be archived on GitHub, it should include local copies of the data resource (likely a PDF article) and any spreadsheets or other tools you used for the transcriptions.

# Level 0 data

Data is available for download (@CPEAT2025) and the first thing we do is construct the download files and URLs.

```{r}
#| label: downloadCPEAT
#| code-fold: true

basenames.arr <- allURLs.df$downloadData |> 
  # start with:
  # "https://doi.pangaea.de/10.1594/PANGAEA.889936?format=textfile"
  str_extract(pattern = '(?<=pangaea.de/).*(?=.format)') |> 
  # extract the string between the doi url and the format information:
  # 10.1594/PANGAEA.889936
  str_replace(pattern = '/', replacement = '_') |>
  # replace the forward slash so that it is not treated as a folder
  # 10.1594_PANGAEA.889936
  paste0('.txt')
  # add the extension

download.flag <- !file.exists(file.path(dataDownload.dir, basenames.arr))

if(any(download.flag)){
  download.file(url = allURLs.df$downloadData[download.flag], 
                destfile = file.path(dataDownload.dir,
                                     basenames.arr[download.flag]))
}

```

Go through and read in the text of the PANGAEA files.
Then split the meta and primary data.

```{r}
#| label: loadPreLevel0
#| code-fold: true
#| warning: false

basenames.ls <- setNames(object = as.list(basenames.arr), str_remove(basenames.arr, '.txt'))
all.text <- plyr::llply(.data = basenames.ls, 
                        .fun = function(basename.str){
  readr::read_file(file.path(dataDownload.dir, basename.str))
})

all.meta <- plyr::ldply(.data = all.text,
                        .fun = function(file.str){
  #### Parse the first level of the metadata ####
  #file.str <- all.text$`10.1594_PANGAEA.928061`
  header.str <- file.str |>
    str_extract(regex('(?<=/\\* ).*(?=\\*/)', multiline=TRUE, dotall=TRUE))
  
  meta.df <- header.str |>
    str_split_1('(?<=\\n)[^\\t]*\\:') |>
    as.list() |>
    setNames(c('meta', str_extract_all(header.str, '(?<=\\n)[^\\t]*\\:') |> 
                 unlist() |>
                 str_remove('\\:$'))) |>
    as_tibble_row()
  return(meta.df)
}, .id = 'doi') 

all.primary <- plyr::ldply(.data = all.text, .fun = function(file.str){
  
#### Parse the primary data file ####

  header.str <- file.str |> #all.text[388] |> #
  str_extract(regex('(?<=\\*/\\n)[^\\n]*', multiline=TRUE, dotall=TRUE)) |>
    str_split(patter = '\\t') |>
    unlist()
  
  #"10.1594_PANGAEA.928439" index 388 has an extra 3 at the end of the file randomly, this throws a warning but does not affect how the data is read in
primary.df <- file.str |> #all.text[388] |> #
  str_extract(regex('(?<=\\*/\\n).*', multiline=TRUE, dotall=TRUE)) |>
  read_tsv(col_types = cols(.default = col_character()),
           skip = 1, col_names = FALSE) |>
  mutate(across(.cols = everything(), .fns = trimws)) |>
  mutate(row_id = paste0('R',1:n())) |>
  pivot_longer(cols = -row_id, 
               names_to = 'column_index', values_to = 'with_entry') |>
  full_join(tibble(column_index = paste0('X', 1:length(header.str)),
                   column_name = header.str),
            by = join_by(column_index))

  return(primary.df)
}, .id = 'doi')


```

Finally split the data into a normalized set of tables.

```{r}
#| label: processHeader
#| code-fold: true

# study.df <- all.meta |>
#   select(doi, citation = Citation, 
#          replaced_by = `Replaced by`, related_to = `Related to`,
#          further_details = `Further details`,
#          projects = `Project(s)`,
#          change_history = `Change history`,
#          license = License,
#          size = Size, abstract = Abstract,
#          keyword = `Keyword(s)`, status = Status) |>
#   mutate(across(everything(), trimws)) |>
#   mutate(across(c(projects, license, keyword, status), as.factor)) |>
#   mutate(replaced_by_doi = str_extract(replaced_by, '10\\.1594/PANGAEA\\.\\d*') |>
#            str_replace('/', '_'))


#### core data (pre-processing) ####
#### to be broken up into coverage, event, and parameter information
core.df <- all.meta |>
  select(doi, coverage = Coverage,
         event = `Event(s)`, parameters = `Parameter(s)`) |>
  separate_wider_delim(cols = parameters, 
                       delim = '\t',
                       names = paste0('X', 0:14),
                       too_few = 'align_start')


#identfy and process the sub-patterns
structures.df <- all.meta |>
  select(Coverage, `Event(s)`, Size, `Parameter(s)`) |>
  mutate(
    Coverage_pattern = 
      str_replace_all(Coverage, '\\-?\\d*\\.?\\d+', '%d'),
    Events_pattern = 
      str_replace(`Event(s)`, '^[^\\*]*\\*', '%s') |>
      str_replace(':[^\\*]*$', ': %s') |>
      str_replace_all(':[^\\*]*\\*', ': %s'),
    Size_pattern = 
      str_replace_all(Size, '\\d+', '%d'))

  ##Do this --
  ## - [x] Coverage: Separate variables based on * and \n, then by [name] : [entry], then extract unit from entry. Strip white space
  ## - [x] Events: Separate variables based on * , then by [name] : [entry], process Comments via ; split, then by [name] : [entry]
  ## -[x] Parameters: Separate and process the parameter descriptions by str subtraction

### size data ####
### number of data points for each doi
size.df <- all.meta |>
  select(doi, Size) |>
  mutate(value = str_extract(Size, '\\d+'),
         unit = str_remove(Size, '\\d+'),
         of_variable = 'data_size') |>
  mutate(across(everything(), trimws)) |>
  pivot_longer(cols = c(value, unit), names_to = 'is_type', values_to = 'with_entry') |>
  select(doi, of_variable, is_type, with_entry)

#### coverage data ####
#### lat/long and core depth interval
coverage.df <- all.meta |>
  select(doi, temp_str = Coverage) |>
  mutate(temp_str = trimws(temp_str)) |>
  separate_longer_delim(temp_str, delim = stringr::regex('\\*|\\n')) |>
  separate_wider_delim(temp_str, delim = ':', names = c('of_variable', 'text')) |>
  mutate(across(everything(), trimws)) |>
  mutate(value = str_remove(text, ' c?m$'),
         unit = trimws(str_extract(text, ' c?m$'))) |>
  select(-text) |>
  pivot_longer(cols = c(value, unit), names_to = 'is_type', values_to = 'with_entry', values_drop_na = TRUE) |>
  mutate(across(everything(), trimws))
  
#### event data (pre-processing) ####
#### lat/long, location (region), elevation, method and device (coring), core recovery length, core penetration depth, and structured comments (processed next)
events.df <- all.meta |>
  select(doi, temp_str = `Event(s)`) |>
  mutate(core_name = str_extract(temp_str, '^.*(?= \\* LATITUDE)')) |>
  mutate(temp_str = str_remove(temp_str, '^.* \\* (?=LATITUDE)')) |>
  separate_wider_delim(temp_str, names = paste0('X', 1:10), 
                       delim = ' * ',
                       too_few = "align_start") |>
  pivot_longer(cols = starts_with('X'),
               names_to = 'drop_names',
               values_to = 'component',
               values_drop_na = TRUE) |>
  mutate(is_type = str_extract(component, '^[^:]+'),
         with_entry = str_remove(component, '^[^:]+: ')) |>
  select(doi, is_type, with_entry) |>
  mutate(across(everything(), trimws)) |>
  pivot_wider(names_from = is_type, values_from = with_entry)

### event comment data ####
### coring year, peatland type, basal age, basal age depth, core microtopography, core length, number of dates, carbon rate site, peat properties sample size, bulk density sample volumne, surface age, altitude, site name, and comment
events_comment.df <- events.df |>
  select(doi, COMMENT) |>
  #remove refernce to core name in comments
  mutate(COMMENT = str_remove(COMMENT,'^.*e[ta]+ils.*(?=c|Coring year)')) |>
  mutate(COMMENT = str_replace(COMMENT, 'sphagnum, Volume of bulk density samples', 'sphagnum; Volume of bulk density samples')) |>#X3
  mutate(COMMENT = str_replace(COMMENT, 'Stordalen_core2 Dominant peat type', 'Stordalen_core2; Dominant peat type')) |> #X2
  mutate(COMMENT = str_replace(COMMENT, 'KOE.', 'KOE')) |>
  mutate(COMMENT = str_replace(COMMENT, '17 samples:', '17 samples - ')) |>
  mutate(COMMENT = str_replace(COMMENT, 'uncal., basal', 'uncal.; basal')) |>
  mutate(COMMENT = str_replace(COMMENT, 'basal age 1', 'basal age: 1')) |>
  separate_longer_delim(cols = 'COMMENT', delim = ';') |>
  mutate(COMMENT = trimws(COMMENT)) |>
separate_wider_delim(cols = COMMENT, delim = ':',
                       names = c('of_variable', 'with_entry'), too_few = 'align_end') |>
  filter(!(is.na(with_entry) & is.na(of_variable))) |>
  mutate(of_variable = if_else(is.na(of_variable), 
                               'COMMENT', of_variable)) |>
  mutate(of_variable = paste0('EVENT::COMMENT::',str_to_lower(of_variable)))

### event (clean) data ####
### lat/long, location (region), elevation, method and device (coring), core recovery length, and core penetration depth
### Note structured comments are processed above seperately
events_clean.df <- events.df |>
  select(-COMMENT) |>
  pivot_longer(-doi, names_to = 'of_variable', values_to='temp',
               values_drop_na = TRUE) |>
  mutate(value = str_remove(temp, ' c?m$'),
         unit = trimws(str_extract(temp, ' c?m$'))) |>
  select(-temp) |>
  pivot_longer(cols = c(value, unit), names_to = 'is_type', values_to = 'with_entry', values_drop_na = TRUE) |>
  mutate(of_variable = paste0('EVENT::', of_variable))

#### column information ####
#### column data model includes column index, name as `of_variable`, and `is_type` including: description, unit, comment, MethodDevice, geocode, and PI
column_meta.df <- all.meta |>
  select(doi, `Parameter(s)`) |>
  separate_wider_delim(cols = `Parameter(s)`, 
                       delim = '\t',
                       names = paste0('X', 0:14),
                       too_few = 'align_start') |>
  select(-X0) |>
  pivot_longer(cols = starts_with('X'),
               names_to = 'column_index',
               values_to = 'column_name',
               values_drop_na = TRUE) |>
  #mutate(column_name_match = str_detect(column_name, '^.+ \\*( GEOCODE \\*)? PI:.+( \\* METHOD/DEVICE:.+)?( \\* COMMENT:.+)?$')) |>
  mutate(comment = str_extract(column_name, '(?<= \\* COMMENT:).+$'),
         MethodDevice = str_extract(
           str_remove(column_name, '( \\* COMMENT:.+)?$'), #trim the end
           '(?<= \\* METHOD/DEVICE:).+$'), #extraction pattern
         PI = str_extract(
           str_remove(column_name, 
                      '( \\* METHOD/DEVICE:.+)?( \\* COMMENT:.+)?$'), #trim
           '(?<= PI: ).+$'), #extract
         geocode = str_extract(column_name, 'GEOCODE'),
         temp = str_remove(column_name, ' \\*( GEOCODE \\*)? PI:.+( \\* METHOD/DEVICE:.+)?( \\* COMMENT:.+)?$')) |>
  mutate(description = str_remove(temp, '[\\[\\(].*$'),
         unit = str_extract(temp, '(?<=\\[).+(?=\\])'),
         of_variable = str_extract(temp, '(?<=\\().+(?=\\))')) |>
  select(!c(column_name, temp)) |>
  mutate(across(everything(), trimws)) |>
  pivot_longer(cols = -c(doi, column_index, of_variable),
               names_to = 'is_type',
               values_to = 'with_entry',
               values_drop_na = TRUE)
  
###Compile study-level data####
###put everything together except the column and layer data
study_meta.df <- all.meta |>
  #trim out the things that don't need heavy processing
  select(doi, citation = Citation, 
         replaced_by = `Replaced by`, 
         related_to = `Related to`, 
         further_details = `Further details`,
         projects = `Project(s)`, 
         change_history = `Change history`, 
         license = License, 
         abstract = Abstract, 
         keywords = `Keyword(s)`, 
         status = Status, 
         header_comment = Comment) |>
  pivot_longer(cols = -doi, 
               names_to = 'of_variable', values_to = 'with_entry',
              values_drop_na = TRUE) |>
  mutate(is_type = 'value') |>
  #pull in the processed data
  bind_rows(size.df,
            events_clean.df,
            events_comment.df,
            coverage.df) |>
  mutate(across(everything(), trimws))

####Create level 0 data list####
#put it all together
lvl0_data.ls <- list(study = study_meta.df,
                columns = column_meta.df,
                primary = all.primary)

# memory management
#rm(list = setdiff(ls(), variable_keep))
```

There was some decision to make here on if we are going to go with a core based list or data type. 
We went with data type (`study`, `column`, `primary`) instead.

```{r readLevel0}
#This chunk has two purposes. 
#...1) Check the formatting by reading in everything 
#...2) Create a list of everything to process later in level 1

data.lvl0.ls <- list(
  #Read in a list of all the bib files
  citation = list(
    #Citation for the article transcriptions are pulled from
    primary = read.bib(file = primaryCitation.file), 
    #Citations for all referenced articles
    methods = read.bib(file = methodsCitation.file)
  ),
  #Read in the text transcription of the article's methods section
  method = read_lines(file = methods.file),
  #Read in the results as tables or figure transcriptions. This includes
  #...the caption as well as the tables themselves
  data = lvl0_data.ls,
)

```

```{r}
#| label: checkReadFunction_lvl0
#| eval: false

datafunction.lvl0.ls <- readAuthorYYYY(dataDir = '.',
                                    dataLevel = 'level0')

if(isTRUE(all.equal(datafunction.lvl0.ls, data.lvl0.ls))){
  print('Read function matches code here.')
}else{
  print('There is a mismatch in the data objects between the code here and the read function.')
}

```


# References

<!---- This space will be filled with the citations when rendered. Leave this blank. ---->

